name: 'Build and Push Image'
description: 'Build and push the Docker image to the registry'
inputs:
  registry_project:
    description: 'Registry project name'
    required: true
    default: 'test-devops'
  registry_repository:
    description: 'Registry repository name'
    required: true
    default: 'python-artifact'
  harbor-token:
    description: 'Harbor robot account token'
    required: true
    default: ''

runs:
  using: "composite"
  steps:

    #- name: Build and push
    #  id: build_and_push_to_harbor
    #  shell: bash
    #  run: |
    #    AUTH=$(echo -n robot\$ikusigh:${{ inputs.harbor-token }} | base64)
    #    cat << EOF > config.json
    #    {
    #      "auths":{
    #        "192.168.50.127:30002/${{ inputs.registry_project }}/${{ inputs.registry_repository }}":{
    #          "username":"robot\$ikusigh","password":"${{ inputs.harbor-token }}","auth":"${AUTH}"
    #        }
    #      }
    #    }
    #    EOF
    #    docker run \
    #      -v $(pwd):/workspace \
    #      -v $(pwd)/config.json:/kaniko/.docker/config.json:ro \
    #      gcr.io/kaniko-project/executor:latest \
    #        --context . \
    #        --destination 192.168.50.127:30002/${{ inputs.registry_project }}/${{ inputs.registry_repository }}:1


    - name: Build and Push with Kaniko (Direct Execution)
      shell: bash
      run: |
        # 1. Preparar el contexto de autenticación
        # Escapamos el $ para que bash no lo interprete
        AUTH=$(echo -n "robot\$ikusigh:${{ inputs.harbor-token }}" | base64)
        
        # Creamos un directorio local para la config de Docker
        mkdir -p ./kaniko-home/.docker
        cat << EOF > ./kaniko-home/.docker/config.json
        {
          "auths": {
            "192.168.50.127:30002": {
              "auth": "$AUTH"
            }
          }
        }
        EOF

        # 2. Ejecutar Kaniko usando la imagen oficial mediante un truco de ARC
        # Como no podemos hacer 'docker run', lanzamos kaniko usando el ejecutor
        # de contenedores que ya trae tu infraestructura de Kubernetes.
        
        echo "Lanzando constructor Kaniko..."
        
        # Usamos el binario de kaniko directamente si el runner es una imagen de kaniko
        # O, si tu runner es una imagen de Ubuntu, descargamos el binario estático:
        
        if [ ! -f /kaniko/executor ]; then
          echo "Descargando binario de Kaniko..."
          # Descargamos el ejecutor estático (no requiere instalación)
          curl -LO https://github.com/GoogleContainerTools/kaniko/releases/latest/download/executor
          chmod +x executor
          KANIKO_EXEC="./executor"
        else
          KANIKO_EXEC="/kaniko/executor"
        fi

        # 3. Ejecución real
        $KANIKO_EXEC \
          --context "${{ github.workspace }}" \
          --dockerfile "${{ github.workspace }}/Dockerfile" \
          --destination "192.168.50.127:30002/${{ inputs.registry_project }}/${{ inputs.registry_repository }}:1" \
          --insecure \
          --skip-tls-verify \
          --docker-config-json ./kaniko-home/.docker/config.json