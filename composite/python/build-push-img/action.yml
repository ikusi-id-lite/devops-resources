name: 'Build and Push Image'
description: 'Build and push the Docker image to the registry'
inputs:
  registry_project:
    description: 'Registry project name'
    required: true
    default: 'test-devops'
  registry_repository:
    description: 'Registry repository name'
    required: true
    default: 'python-artifact'
  harbor-token:
    description: 'Harbor robot account token'
    required: true
    default: ''

runs:
  using: "composite"
  steps:

    #- name: Build and push
    #  id: build_and_push_to_harbor
    #  shell: bash
    #  run: |
    #    AUTH=$(echo -n robot\$ikusigh:${{ inputs.harbor-token }} | base64)
    #    cat << EOF > config.json
    #    {
    #      "auths":{
    #        "192.168.50.127:30002/${{ inputs.registry_project }}/${{ inputs.registry_repository }}":{
    #          "username":"robot\$ikusigh","password":"${{ inputs.harbor-token }}","auth":"${AUTH}"
    #        }
    #      }
    #    }
    #    EOF
    #    docker run \
    #      -v $(pwd):/workspace \
    #      -v $(pwd)/config.json:/kaniko/.docker/config.json:ro \
    #      gcr.io/kaniko-project/executor:latest \
    #        --context . \
    #        --destination 192.168.50.127:30002/${{ inputs.registry_project }}/${{ inputs.registry_repository }}:1


    - name: Build and Push with Kaniko Container
      shell: bash
      run: |
        # 1. Preparar credenciales de Harbor
        # El nombre de usuario tiene un $, lo escapamos con \ para que Bash no lo borre
        AUTH=$(echo -n "robot\$ikusigh:${{ inputs.harbor-token }}" | base64)
        
        # Creamos un directorio temporal para la config de Docker
        mkdir -p ./kaniko-config
        
        echo "{\"auths\":{\"192.168.50.127:30002\":{\"auth\":\"$AUTH\"}}}" > ./kaniko-config/config.json

        # 2. Ejecutar Kaniko usando una imagen de contenedor directamente
        # Al no tener Docker en el runner, usamos este truco: 
        # Corremos el ejecutor de kaniko mediante un contenedor efímero.
        # Si tu Runner es la imagen estándar de ARC, usaremos 'docker run' 
        # PERO, como no tienes Docker, la forma correcta en K8s es que el runner
        # tenga acceso al binario o usar un Sidecar.
        
        # SI TU RUNNER NO TIENE DOCKER, USAMOS ESTE COMANDO DE KANIKO:
        # Nota: Esto asume que el runner puede ejecutar imágenes de contenedor.
        
        echo "Iniciando construcción con Kaniko..."
        
    - name: Kaniko Executor
      # Esta es la forma oficial de GitHub para correr un contenedor SIN 'docker run'
      # Usamos la imagen oficial de Google Kaniko directamente
      uses: docker://gcr.io/kaniko-project/executor:latest
      with:
        args: >-
          --context=${{ github.workspace }}
          --dockerfile=${{ github.workspace }}/Dockerfile
          --destination=192.168.50.127:30002/${{ inputs.registry_project }}/${{ inputs.registry_repository }}:1
          --insecure
          --skip-tls-verify
          --docker-config-json=${{ github.workspace }}/kaniko-config